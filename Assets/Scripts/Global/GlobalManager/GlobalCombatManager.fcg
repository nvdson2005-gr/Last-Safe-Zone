/* 
Global Combat Manager
This script manages all the interactions when inside the combat phase.
This is the replacement for GlobalRoundHandler.eca
*/
import "../GlobalData/PlayerData.fcg" as PlayerData
import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Combat.fcc" as Combat
import "../GlobalData/TeamsAlive.fcg" as TeamsAlive
import "LevelObject.fcc" as LevelObject
import "Workflow.fcc" as Workflow
import "List.fcc" as List
import "../GlobalData/CombatRoundCounter.fcg" as CombatRoundCounter
import "Player.fcc" as Player
import "../GlobalData/TeamData.fcg" as TeamData
import "Hostility.fcc" as Hostility
import "../GlobalManager/GlobalUIManager.fcg" as GlobalUIManager
import "../GlobalData/TargetAndCombatTimer.fcg" as TargetAndCombatTimer
import "Math.fcc" as Math
import "Items.fcc" as Items
import "../GlobalData/GlobalSafeZones.fcg" as GlobalSafeZones
import "../GlobalManager/GlobalPreparationPhaseManager.fcg" as GlobalPreparationPhaseManager
graph GlobalCombatManager {
    teamsAlive List<Team> = List<Team>{} // List of teams that are still alive in the combat phase
    allDroppedItems List<entity<ItemBase>> = List<entity<ItemBase>>{} // List of all dropped items on ground in each round

    // When the combat phase starts, activate the timer also
    event OnPhaseStart(phase entity<Phase>) {
        if phase<Phase>.Index == EPhase.Combat {
            globalEntity<TargetAndCombatTimer>.StartTimer()
        }
    }

    // When a new round starts, reset the timer and other relevant data
    event OnRoundStart(roundIndex int) {
        if (roundIndex == 0) {
            teamsAlive = globalEntity<TeamsAlive>.GetAliveTeams() // Get the list of alive teams
            // LogInfo("<GlobalCombatManager.fcg>: Round started, teams alive initialized") // Debug Info
        }
    }

    // On Player Be Eliminated, update mini scoreboard
    event OnPlayerBeEliminated(player entity<Player>) {
        globalEntity<GlobalUIManager>.UpdateMiniScoreboard() // Update the mini scoreboard UI after a player is eliminated to update current alives
    }

    // On Player Eliminate, update mini scoreboard and full scoreboard
    event OnPlayerEliminate(player entity<Player>, eliminatedPlayer entity<Player>, damageType DamageType) {
        if damageType != DamageType.ElectricZone && damageType != DamageType.Falling && damageType != DamageType.Exit && damageType != DamageType.Disconnect  {
            globalEntity<PlayerData>.IncreaseKill(player)
            globalEntity<GlobalUIManager>.UpdateMiniScoreboard() // Update the mini scoreboard UI after a player is eliminated to update current alives
        }
        globalEntity<PlayerData>.IncreaseDeath(eliminatedPlayer)
    }

    event OnPlayerDealDamage(attacker entity<Player>, target entity<Player>, damageType DamageType, value int, damagedBodyPart DamagedBodyPartType) {
        if damageType != DamageType.ElectricZone && damageType != DamageType.Falling && damageType != DamageType.Exit && damageType != DamageType.Disconnect  {
            globalEntity<PlayerData>.IncreaseDamage(attacker, value) // Increase damage in the mid game full score board
        }
    }

    func AddItemToList(item entity<ItemBase>) {
        Append(allDroppedItems, item)
    }

    func ClearAllItemsOnGround(){
        for index, item in allDroppedItems {
            // LogError("Destroyed item: " + item)
            Destroy(item)
        }
    }

    /* Check if the combat phase should end
       This function checks the current state of the teams and determines if the combat phase should end.
    */
    func CheckEndCombatCondition() {
        var teamCount int = 0 
        var isTeamAliveList List<bool> = List<bool>{false, false, false}
        for index, team in GetAllTeams() {
            if(!team<Team>.IsAced) {
                isTeamAliveList[index] = true
                teamCount = teamCount + 1
            }
        }
        // Check if there is only one team left
        if(teamCount <= 1) {
            for index, team in isTeamAliveList {
                if team == true {
                    globalEntity<TargetAndCombatTimer>.ResetTimer()
                    LogInfo("<GlobalCombatManager.fcg>: Team " + index + " is the last team standing.")
                    ClearAllItemsOnGround()
                    DispatchEvent(CombatEnd, thisEntity, List<object>{GetAllTeams()[index]})
                    return
                }
            }
        }
        // Exception: No team wins
        if(teamCount == 0) {
            ClearAllItemsOnGround()
            globalEntity<TargetAndCombatTimer>.ResetTimer()
            DispatchEvent(NoTeamWinException, thisEntity, List<object>{})
        }
    }
}