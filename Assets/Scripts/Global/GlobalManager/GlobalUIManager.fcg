import "Player.fcc" as Player
import "LevelObject.fcc" as LevelObject
import "Hostility.fcc" as Hostility
import "Database.fcc" as Database
import "Convert.fcc" as Convert
import "List.fcc" as List
import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Hud.fcc" as Hud
import "Map.fcc" as Map
import "../GlobalData/TeamPoints.fcg" as TeamPoints
import "../GlobalData/TeamData.fcg" as TeamData
import "../GlobalData/CombatRoundCounter.fcg" as CombatRoundCounter
import Res from "EditorGenLib.fcc"
graph GlobalUIManager {
    fullScoreBoardUIDict Map<entity<Player>, entity<CustomUI>> // Map to associate players with their full scoreboard UIs
    miniScoreBoardUIdict Map<entity<Player>, entity<CustomUI>>
    openingUIDict Map<entity<Player>, entity<UIOpeningBanner>>
    tooltipUIDict Map<entity<Player>, entity<BuiltInUI>> // Map to associate players with their tooltip UIs
    roundInfoUIDitct Map<entity<Player>, entity<UISimpleRoundStartBanner>> // Map to associate players with their round info UIs
    event OnAwake() {
        openingUIDict = Map<entity<Player>, entity<UIOpeningBanner>>{}
        miniScoreBoardUIdict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map of players' mini scoreboards at the start of the game
        fullScoreBoardUIDict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map of players' full scoreboards at the start of the game
        tooltipUIDict = Map<entity<Player>, entity<UISimpleRoundStartBanner>>{} // Initialize the map of players' tooltip UIs at the start of the game
        roundInfoUIDitct = Map<entity<Player>, entity<UISimpleRoundStartBanner>>{} // Initialize the map of players' round info UIs at the start of the game
    }

   func CreateGlobalOpeningHUD(player entity<Player>){
        CreateBuiltInUI(out var createdHUD, player, EResInternalHud.OpeningBannerHud as BuiltInUIType)
        createdHUD<UIOpeningBanner>.Title = LocString{"GAME_NAME", List<string>{}}
        createdHUD<UIOpeningBanner>.Description = LocString{"GAME_DESCRIPTION", List<string>{}}
        createdHUD<UIOpeningBanner>.Icon = EResSprite.logo
        openingUIDict[player] = createdHUD as entity<UIOpeningBanner>
    }

    func RemoveGlobalOpeningHUD() {
        for player, hud in openingUIDict {
            DestroyBuiltInUI(hud)
            Map.Remove(openingUIDict, player) // Remove the HUD from the dictionary after destroying it
        }
    }

    func RegisterMiniScoreBoard(player entity<Player>) bool {
        CreateCustomUI(out var miniScoreBoard, player, EResUI.MiniScoreBoardUI);
        if (miniScoreBoardUIdict == nil) { miniScoreBoardUIdict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(miniScoreBoardUIdict, player)) {
            miniScoreBoardUIdict[player] = miniScoreBoard // Associate the player with their mini scoreboard
            var playersTeam entity<Team> = player<Player>.HostTeam
            // var playersTeam entity<Team> = nil
            // for index, team in GetAllTeams() {
            //     for index, member in team<Team>.AllTeammates {
            //         if member == player {
            //             playersTeam = team
            //             break
            //         }
            //     }
            //     if playersTeam != nil {
            //         break
            //     }
            // }
            var w entity<UIWidget>
            var scoreW entity<UIWidget>
            var aliveWidget entity<UIWidget>
            if(playersTeam<Team>.TeamSeq == 1) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1ScoreBG as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1AlivesLayout as CustomUIWidgetID)
            } else if(playersTeam<Team>.TeamSeq == 2) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2ScoreBG as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2AlivesLayout as CustomUIWidgetID)
            } else if(playersTeam<Team>.TeamSeq == 3) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3ScoreBg as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3AlivesLayout as CustomUIWidgetID)
            }
            if(w== nil) {
                LogError("<GlobalUIManager.fcg>: Failed to get widget for player: " + player<Entity>.Name) // Error Info
                return false;
            }
            var aliveWidgetList = GetChildren(aliveWidget)
            w<UIWidgetImage>.Color = #FFB400
            // scoreW<UIWidgetImage>.Color = #FFB400
            for index, widget in aliveWidgetList {
                widget<UIWidgetImage>.Color = #FFB400
            }
            // LogInfo("<GlobalUIManager.fcg>: Registered mini scoreboard for player: " + player<Entity>.Name) // Debug Info
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Mini scoreboard already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    func UpdateTeamPointsAndAlivesInMiniScoreboard(){
        for index, team in GetAllTeams() {
            var point = globalEntity<TeamData>.GetTeamPoint(team)
            var aliveCount = 0
            for index, player in team<Team>.AllTeammates {
                if player<Player>.HP > 0 {
                    aliveCount = aliveCount + 1
                }
            }
            for index, player in GetAllPlayers() {
                if(Map.ContainKey(miniScoreBoardUIdict, player)) {
                    var ui = miniScoreBoardUIdict[player]
                    var widget entity<UIWidget>
                    var alivesWidget entity<UIWidget>
                    if(team<Team>.TeamSeq == 1) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team1Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team1AlivesLayout as CustomUIWidgetID)
                    } else if(team<Team>.TeamSeq == 2) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team2Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team2AlivesLayout as CustomUIWidgetID)
                    } else if(team<Team>.TeamSeq == 3) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team3Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team3AlivesLayout as CustomUIWidgetID)
                    } 
                    LogError(widget)
                    widget<UIWidgetLabel>.Content = ToString(point) 
                    var aliveWidgetList = GetChildren(alivesWidget)
                    for index, widget in aliveWidgetList {
                        if index >= aliveCount {
                            SetActive(widget, false) // Hide the widget if the index is greater than or equal to the alive count
                        } else {
                            SetActive(widget, true) // Show the widget if the index is less than the alive count
                        }
                    }
                }
            }
        }
    }

    func RegisterFullScoreBoard(player entity<Player>) bool {
        CreateCustomUI(out var fullScoreBoard, player, EResUI.FullScoreBoard);
        if (fullScoreBoardUIDict == nil) { fullScoreBoardUIDict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(fullScoreBoardUIDict, player)) {
            fullScoreBoardUIDict[player] = fullScoreBoard // Associate the player with their full scoreboard
            // LogInfo("<GlobalUIManager.fcg>: Registered full scoreboard for player: " + player<Entity>.Name) // Debug Info
            var playerTeam = player<Player>.HostTeam
            var teamWidget entity<UIWidget>
            if playerTeam<Team>.TeamSeq == 1 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank1BG)
            } else if playerTeam<Team>.TeamSeq == 2 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank2BG)
            } else if playerTeam<Team>.TeamSeq == 3 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank3BG)
            }
            teamWidget<UIWidgetImage>.Color = #FFB400 // Set the color of the team widget to a specific color
            fullScoreBoard<CustomUI>.IsVisible = false // Initially set the full scoreboard to not visible
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Full scoreboard already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    // func InitTeamDataInFullScoreBoard(){
    //     for player, ui in fullScoreBoardUIDict {
    //         CreateFromPrefab(out var newTeam, EResPrefab.TeamInfoContainer)
    //         SetParent(EResUIFullScoreBoard.TeamInfoLayout, newTeam, false)
    //     }
    // }

    func SetVisibilityFullScoreBoard(player entity<Player>, isVisible bool) {
        if (Map.ContainKey(fullScoreBoardUIDict, player)) {
            fullScoreBoardUIDict[player]<CustomUI>.IsVisible = isVisible
        }
    }
    
    func UpdateFullScoreBoard(){
        var sortedTeamList List<entity<Team>> = globalEntity<TeamData>.GetSortedTeamList()
        var rankCount int = 1
        for index, team in sortedTeamList {
            var scores = globalEntity<TeamData>.GetTeamPoint(team)
            for index, player in GetAllPlayers() {
                if(Map.ContainKey(fullScoreBoardUIDict, player)) {
                    var ui = fullScoreBoardUIDict[player]
                    var rankBgWidget  entity<UIWidget>
                    var nameWidget entity<UIWidget>
                    var scoreWidget entity<UIWidget>
                    if(rankCount == 1) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName1)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.FirstRankTeamBooyah)
                    } else if(rankCount == 2) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName2)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.SecondRankTeamBooyah)
                    } else if(rankCount == 3) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName3)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.ThirdRankTeamBooyah)
                    }
                    // if team<Team>.TeamSeq == 1{
                    //     // nameWidget<UIWidgetLabel>.Content = "Team 1"
                    //     // nameWidget<UIWidgetLabel>.Content = LocString{"TEAM_1", List<string>{}} // Use localization for team names
                    // } else if team<Team>.TeamSeq == 2 {
                    //     // nameWidget<UIWidgetLabel>.Content = "Team 2"
                    //     // nameWidget<UIWidgetLabel>.Content = LocString{"TEAM_2", List<string>{}} // Use localization for team names
                    // } else if team<Team>.TeamSeq == 3 {
                    //     // nameWidget<UIWidgetLabel>.Content = "Team 3"
                    //     // nameWidget<UIWidgetLabel>.Content = LocString{"TEAM_3", List<string>{}} // Use localization for team names
                    // }
                    if team == player<Player>.HostTeam {
                        rankBgWidget<UIWidgetImage>.Color = #FFB400 // Highlight the player's team in the scoreboard
                    } else {
                        rankBgWidget<UIWidgetImage>.Color = #9C9C9C// Set other teams to white
                    }
                    nameWidget<UIWidgetLabel>.Content = LocString{"TEAM", List<string>{ToString(team<Team>.TeamSeq)}} // Use localization for team names
                    scoreWidget<UIWidgetLabel>.Content = ToString(scores)
                }
            }
            rankCount = rankCount + 1;
        }
        // UpdatePlayersInScoreBoard(sortedTeamList);
    }

    async func CreateRoundInfoHUD(){
        for index, player in GetAllPlayers(){
            if (Map.ContainKey(roundInfoUIDitct, player)) {
                roundInfoUIDitct[player]<UISimpleRoundStartBanner>.RoundNumKey = LocString{"ROUND_INFO", List<string>{ToString(globalEntity<CombatRoundCounter>.GetCount())}}
                roundInfoUIDitct[player]<UISimpleRoundStartBanner>.IsVisible = true // Set the round info UI to be visible
                continue; // Skip if the round info UI is already registered
            }
            CreateBuiltInUI(out var createdUI, player, EResInternalHud.RoundInfoHud as BuiltInUIType)
            createdUI<UISimpleRoundStartBanner>.RoundNumKey = LocString{"ROUND_INFO", List<string>{ToString(globalEntity<CombatRoundCounter>.GetCount())}}
            createdUI<UISimpleRoundStartBanner>.IsVisible = true // Set the round info UI to be visible
            roundInfoUIDitct[player] = createdUI as entity<UISimpleRoundStartBanner> // Associate the player with their round info UI
        }
        WaitForMillisecond(2000)
        for index, player in GetAllPlayers(){
            if (Map.ContainKey(roundInfoUIDitct, player)) {
                roundInfoUIDitct[player]<UISimpleRoundStartBanner>.IsVisible = false // Hide the round info UI after a short delay
            }
        }
    }

    async func CreateEndRoundHUD(winningTeam entity<Team>){
        var endRoundUIList = List<entity<UIRoundInfoBanner>>{}
        for index, player in GetAllPlayers(){
            CreateBuiltInUI(out var createdUI, player, EResInternalHud.EndRoundInfoHud as BuiltInUIType)
            createdUI<UIRoundInfoBanner>.Title = LocString{"ROUND_END_INFO", List<string>{}}
            // createdUI<UIRoundInfoBanner>.SubTitle = "Team " + winningTeam<Team>.TeamSeq + " wins the round!"
            createdUI<UIRoundInfoBanner>.SubTitle = LocString{"ROUND_END_SUBTITLE", List<string>{ToString(winningTeam<Team>.TeamSeq)}}
            Append(endRoundUIList, createdUI as entity<UIRoundInfoBanner>) // Add the created UI to the list
        }
        WaitForMillisecond(2000)
        for index, endRoundUI in endRoundUIList {
            DestroyBuiltInUI(endRoundUI)
        }
    }

    func CreateEndGameHUD(team entity<Team>, resultStatus int){
        for index, player in team<Team>.AllTeammates {
            CreateBuiltInUI(out var createdUI, player, EResInternalHud.ResultBannerHud as BuiltInUIType)
            createdUI<UIWinOrLoseBanner>.IsVisible = true
            createdUI<UIWinOrLoseBanner>.Result = resultStatus
        }
    }

    async func SetAllPlayersTooltipStatus(status bool, duration int) {
        var tooltipList List<entity<BuiltInUI>> = List<entity<BuiltInUI>>{}
        for index, player in GetAllPlayers() {
            CreateBuiltInUI(out var tooltip, player, EResInternalHud.TipHud as BuiltInUIType)
            // tooltip<UISimpleTip>.Text = "Click to view scoreboard details"
            // Append(tooltipList, tooltip)
        }
        // WaitForMillisecond(duration)
        // for index, tooltip in tooltipList {
        //     DestroyBuiltInUI(tooltip) // Destroy the tooltip after a short delay
        // }
    }
    // event OnPlayerJoin(player entity<Player>) {
    //     CreateBuiltInUI(out var createdHUD, player, EResInternalHud.TipHud as BuiltInUIType)
    //     // createdHUD<UISimpleTip>.Background = EResSprite.Square 
    //     createdHUD<UITweenTip>.TipsType = 1 
    //     createdHUD<UITweenTip>.Description = "Click in the scoreboard to see details"
    // }

    func RegisterTooltipUI(player entity<Player>) bool {
        if (tooltipUIDict == nil) {
            tooltipUIDict = Map<entity<Player>, entity<BuiltInUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(tooltipUIDict, player)) {
            CreateBuiltInUI(out var tooltipUI, player, EResInternalHud.TipHud as BuiltInUIType) // Create a new tooltip UI for the player
            tooltipUI<UITweenTip>.IsVisible = false // Set the tooltip UI to be invisible initially
            tooltipUI<UITweenTip>.TipsType = 1 // Set the type of the tooltip
            // tooltipUI<UITweenTip>.Description = "Click in the scoreboard to see details" // Set the description for the tooltip UI
            tooltipUI<UITweenTip>.Description = LocString{"SCBOARD_TOOLTIP", List<string>{}} // Use localization for the tooltip description
            tooltipUIDict[player] = tooltipUI // Associate the player with their tooltip UI
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Tooltip UI already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    async func EnableTooltips(){
        for index, player in GetAllPlayers() {
            if (Map.ContainKey(tooltipUIDict, player)) {
                var tooltipUI = tooltipUIDict[player]
                tooltipUI<UITweenTip>.IsVisible = true // Set the tooltip UI to be visible
            } else {
                RegisterTooltipUI(player);
            }
        }
        WaitForMillisecond(5000)
        for player, tooltip in tooltipUIDict {
            if (tooltip<UITweenTip>.IsVisible == true) {
                tooltip<UITweenTip>.IsVisible = false// Set the tooltip UI to be visible
            }
        }
    }

    func UpdatePlayersInScoreBoard(sortedTeamList List<entity<Team>>) {
        // Clear all names first
        // for player, ui in fullScoreBoardUIDict{
        //     var foo int = 1
        //     while foo <= 3 {
        //         var teamWidget entity<UIWidget>
        //         if foo == 1 {
        //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
        //         } else if foo == 2 {
        //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
        //         } else if foo == 3 {
        //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
        //         }
        //         var nameWidgetList = GetChildren(teamWidget)
        //         for index, nameWidget in nameWidgetList {
        //             var textWidget = nameWidget<UIWidgetLabel>
        //             if textWidget<UIWidgetLabel>.Content != " " {
        //                 textWidget<UIWidgetLabel>.Content = " " // Clear the content of the name widget
        //             } else {
        //                 break;
        //             }
        //         }
        //         foo = foo + 1
        //     }
        //     var rankCount int = 1
        //     for index, team in sortedTeamList {
        //         var teamWidget entity<UIWidget>
        //         // if team<Team>.TeamSeq == 1 {
        //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
        //         // } else if team<Team>.TeamSeq == 2 {
        //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
        //         // } else if team<Team>.TeamSeq == 3 {
        //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
        //         // }
        //         if rankCount == 1{
        //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
        //         } else if rankCount == 2 {
        //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
        //         } else if rankCount == 3 {
        //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
        //         }
        //         var nameWidgetList = GetChildren(teamWidget)
        //         for index, player in team<Team>.AllTeammates {
        //             for index, nameWidget in nameWidgetList {
        //                 var textWidget = nameWidget<UIWidgetLabel>
        //                 if textWidget<UIWidgetLabel>.Content == " " {
        //                     textWidget<UIWidgetLabel>.Content = player<Player>.NickName// Set the player's name in the scoreboard
        //                     break;
        //                 }
        //             }
        //         }
        //         rankCount = rankCount + 1
        //     }
        // }
    }
}