/*
Global UI Manager
Handles all UI-related functionalities and interactions for the game.
*/
import "Workflow.fcc" as Workflow
import "Playable.fcc" as Playable
import "Animation.fcc" as Animation
import "Combat.fcc" as Combat
import "../GlobalManager/GlobalSoundManager.fcg" as GlobalSoundManager
import "../GlobalManager/GlobalAnimationManager.fcg" as GlobalAnimationManager
import "../GlobalData/PlayerData.fcg" as PlayerData
import "Math.fcc" as Math
import "Player.fcc" as Player
import "LevelObject.fcc" as LevelObject
import "Hostility.fcc" as Hostility
import "Database.fcc" as Database
import "Convert.fcc" as Convert
import "List.fcc" as List
import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Hud.fcc" as Hud
import "Map.fcc" as Map
import "../GlobalData/TeamPoints.fcg" as TeamPoints
import "../GlobalData/TeamData.fcg" as TeamData
import "../GlobalData/CombatRoundCounter.fcg" as CombatRoundCounter
import "../GlobalData/SpawnPoints.fcg" as SpawnPoints
import "../GlobalManager/GlobalPreparationPhaseManager.fcg" as GlobalPreparationPhaseManager
import "../GlobalData/TargetAndCombatTimer.fcg" as TargetAndCombatTimer
import "../GlobalData/PlayersTimerUI.fcg" as PlayersTimerUI
import "../GlobalData/PlayersTutorial.fcg" as PlayersTutorial
import "../GlobalData/PlayersShopIcon.fcg" as PlayersShopIcon
import Res from "EditorGenLib.fcc"

graph GlobalUIManager {
    fullScoreBoardUIDict Map<entity<Player>, entity<CustomUI>> // Map to associate players with their full scoreboard UIs when combat ends
    miniScoreBoardUIdict Map<entity<Player>, entity<CustomUI>> // Map to associate players with their mini scoreboard UIs
    tooltipUIDict Map<entity<Player>, entity<BuiltInUI>> // Map to associate players with their tooltip UIs
    roundInfoUIDitct Map<entity<Player>, entity<UISimpleRoundStartBanner>> // Map to associate players with their round info UIs

    // Init when the game starts
    event OnAwake() {
        miniScoreBoardUIdict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map of players' mini scoreboards at the start of the game
        fullScoreBoardUIDict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map of players' full scoreboards at the start of the game
        tooltipUIDict = Map<entity<Player>, entity<UISimpleRoundStartBanner>>{} // Initialize the map of players' tooltip UIs at the start of the game
        roundInfoUIDitct = Map<entity<Player>, entity<UISimpleRoundStartBanner>>{} // Initialize the map of players' round info UIs at the start of the game
    }

    /*
    Creates the in-game scoreboard UI for a player.
    @param player: The player entity to create the scoreboard for
    */
    func CreateInGameScoreBoard(player entity<Player>){
        CreateBuiltInUI(out var createdUI, player, EResInternalHud.MultiTeamScoreBoard as BuiltInUIType)
        createdUI<UIMultipleTeamLeaderboardV2>.Players = globalEntity<TeamData>.GetSortedPlayersGroup()
        createdUI<UIMultipleTeamLeaderboardV2>.Ranks = List<int>{1, 2, 3}
        createdUI<UIMultipleTeamLeaderboardV2>.TotalScores = globalEntity<TeamData>.GetSortedScores()
        createdUI<UIMultipleTeamLeaderboardV2>.ScoreTypeNames = List<string>{LocString{"MULTI_SCBOARD_KILL", List<string>{}}, LocString{"MULTI_SCBOARD_DEATH", List<string>{}}, LocString{"MULTI_SCBOARD_DMG", List<string>{}}}
        var playerScoreList = List<List<int>>{}
        for index, team in createdUI<UIMultipleTeamLeaderboardV2>.Players {
            for idx, player in team {
                Append(playerScoreList, globalEntity<PlayerData>.GetPlayerData(player))
            }
        }
        createdUI<UIMultipleTeamLeaderboardV2>.Scores = playerScoreList
    }

    /*
    Creates the global opening HUD for a player.
    @param player: The player entity to create the HUD for
    */
    async func CreateGlobalOpeningHUD(player entity<Player>){
        if globalEntity<Global>.CurrentPhaseIndex == EPhase.Preparation || globalEntity<Global>.CurrentPhaseIndex == EPhase.Start{
            CreateBuiltInUI(out var createdHUD, player, EResInternalHud.OpeningBannerHud as BuiltInUIType)
            createdHUD<UIOpeningBanner>.Title = LocString{"GAME_NAME", List<string>{}}
            createdHUD<UIOpeningBanner>.Description = LocString{"GAME_DESCRIPTION", List<string>{}}
            createdHUD<UIOpeningBanner>.Icon = EResSprite.logo
            WaitForMillisecond(8000)
            DestroyBuiltInUI(createdHUD)
        }
    }

    /*
    Registers the mini scoreboard UI for a player.
    @param player: The player entity to register the mini scoreboard for
    @return: True if the registration was successful, false otherwise
    */
    func RegisterMiniScoreBoard(player entity<Player>) bool {
        CreateCustomUI(out var miniScoreBoard, player, EResUI.MiniScoreBoardUI);
        if (miniScoreBoardUIdict == nil) { miniScoreBoardUIdict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(miniScoreBoardUIdict, player)) {
            miniScoreBoardUIdict[player] = miniScoreBoard // Associate the player with their mini scoreboard
            var playersTeam entity<Team> = player<Player>.HostTeam
            var w entity<UIWidget>
            var scoreW entity<UIWidget>
            var aliveWidget entity<UIWidget>
            if(playersTeam<Team>.TeamSeq == 1) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1ScoreBG as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1AlivesLayout as CustomUIWidgetID)
            } else if(playersTeam<Team>.TeamSeq == 2) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2ScoreBG as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2AlivesLayout as CustomUIWidgetID)
            } else if(playersTeam<Team>.TeamSeq == 3) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3ScoreBg as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3AlivesLayout as CustomUIWidgetID)
            }
            if(w== nil) {
                LogError("<GlobalUIManager.fcg>: Failed to get widget for player: " + player<Entity>.Name) // Error Info
                return false;
            }
            var aliveWidgetList = GetChildren(aliveWidget)
            // LogError(aliveWidgetList)
            w<UIWidgetImage>.Color = #FFB400
            // scoreW<UIWidgetImage>.Color = #FFB400
            for index, widget in aliveWidgetList {
                widget<UIWidgetImage>.Color = #FFB400
                // widget<UIWidget>.Active = false
            }
            // LogInfo("<GlobalUIManager.fcg>: Registered mini scoreboard for player: " + player<Entity>.Name) // Debug Info
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Mini scoreboard already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    /**
     * Creates the plus point animation for the winning team in the end combat full scoreboard.
     * @param winningTeam: The winning team entity
     */
    async func CreatePlusAnimation(winningTeam entity<Team>){
        for index, player in GetAllPlayers() {
            var widget entity<UIWidget>
            if winningTeam<Team>.TeamSeq == 1 {
                widget = GetWidgetFromCustomUI(player, miniScoreBoardUIdict[player], EResUIMiniScoreBoardUI.TextAnimTeam1 as CustomUIWidgetID)
            } else if winningTeam<Team>.TeamSeq == 2 {
                widget = GetWidgetFromCustomUI(player, miniScoreBoardUIdict[player], EResUIMiniScoreBoardUI.TextAnimTeam2 as CustomUIWidgetID)
            } else if winningTeam<Team>.TeamSeq == 3 {
                widget = GetWidgetFromCustomUI(player, miniScoreBoardUIdict[player], EResUIMiniScoreBoardUI.TextAnimTeam3 as CustomUIWidgetID)
            }
            start globalEntity<GlobalAnimationManager>.DOIncreaseTween(widget) // Start the increase tween animation for the widget
        }
    }

    // Update mini scoreboard, including team points and current alives in each team
    func UpdateMiniScoreboard(){
        for index, team in GetAllTeams() {
            var point = globalEntity<TeamData>.GetTeamPoint(team)
            var aliveCount = 0
            for index, player in team<Team>.AllTeammates {
                if player<Player>.HP > 0 {
                    aliveCount = aliveCount + 1
                }
            }
            for index, player in GetAllPlayers() {
                if(Map.ContainKey(miniScoreBoardUIdict, player)) {
                    var ui = miniScoreBoardUIdict[player]
                    var widget entity<UIWidget>
                    var alivesWidget entity<UIWidget>
                    if(team<Team>.TeamSeq == 1) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team1Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team1AlivesLayout as CustomUIWidgetID)
                    } else if(team<Team>.TeamSeq == 2) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team2Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team2AlivesLayout as CustomUIWidgetID)
                    } else if(team<Team>.TeamSeq == 3) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team3Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team3AlivesLayout as CustomUIWidgetID)
                    } 
                    widget<UIWidgetLabel>.Content = ToString(point) 
                    var aliveWidgetList = GetChildren(alivesWidget)
                    for index, widget in aliveWidgetList {
                        if index >= aliveCount {
                            widget<UIWidget>.Active = false // Hide the widget if the index is greater than or equal to the alive count
                        } else {
                            widget<UIWidget>.Active = true // Show the widget if the index is less than the alive count
                        }
                    }
                }
            }
        }
    }

    /*
    Registers the full scoreboard UI for a player.
    @param player: The player entity to register the full scoreboard for
    @return: True if the registration was successful, false otherwise
    */
    func RegisterFullScoreBoard(player entity<Player>) bool {
        CreateCustomUI(out var fullScoreBoard, player, EResUI.FullScoreBoard);
        if (fullScoreBoardUIDict == nil) { fullScoreBoardUIDict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(fullScoreBoardUIDict, player)) {
            fullScoreBoardUIDict[player] = fullScoreBoard // Associate the player with their full scoreboard
            // LogInfo("<GlobalUIManager.fcg>: Registered full scoreboard for player: " + player<Entity>.Name) // Debug Info
            var playerTeam = player<Player>.HostTeam
            var teamWidget entity<UIWidget>
            var teamNameBgWidget entity<UIWidget>
            var pointBgWidget entity<UIWidget>
            if playerTeam<Team>.TeamSeq == 1 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank1BG)
                teamNameBgWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank1NameBg)
                pointBgWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank1BooyahBg)
            } else if playerTeam<Team>.TeamSeq == 2 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank2BG)
                teamNameBgWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank2NameBg)
                pointBgWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank2BooyahBg)
            } else if playerTeam<Team>.TeamSeq == 3 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank3BG)
                teamNameBgWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank3NameBg)
                pointBgWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank3BooyahBg)
            }
            teamWidget<UIWidgetImage>.Color = #FFB400 // Set the color of the team widget to a specific color
            teamNameBgWidget<UIWidgetImage>.Color = #FFB400 // Set the color of the team name background widget
            pointBgWidget<UIWidgetImage>.Color = #FFB400 // Set the color of the point background widget
            fullScoreBoard<CustomUI>.IsVisible = false // Initially set the full scoreboard to not visible
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Full scoreboard already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    /*
    Sets the visibility of the full scoreboard for a player.
    @param player: The player entity to set the visibility for
    @param isVisible: The visibility state to set
    */
    func SetVisibilityFullScoreBoard(player entity<Player>, isVisible bool) {
        if (Map.ContainKey(fullScoreBoardUIDict, player)) {
            fullScoreBoardUIDict[player]<CustomUI>.IsVisible = isVisible
        }
    }

    /*
    Update full scoreboard when the round ends, together with an animation
    @param wonTeam: The team that won the round
    */
    async func UpdateFullScoreBoardWinTeam(wonTeam entity<Team>) {
        WaitForMillisecond(2000)
        var sortedTeamList List<entity<Team>> = globalEntity<TeamData>.GetSortedTeamList()
        var rankCount int = 1
        for index, team in sortedTeamList {
            var scores = globalEntity<TeamData>.GetTeamPoint(team)
            for index, player in GetAllPlayers() {
                if(Map.ContainKey(fullScoreBoardUIDict, player)) {
                    var ui = fullScoreBoardUIDict[player]
                    var rankBgWidget  entity<UIWidget>
                    var nameWidget entity<UIWidget>
                    var scoreWidget entity<UIWidget>
                    var nameBgWidget entity<UIWidget>
                    var pointBgWidget entity<UIWidget>
                    var increaseWidget entity<UIWidget>
                    if(rankCount == 1) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName1)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.FirstRankTeamBooyah)
                        nameBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1NameBg) 
                        pointBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1BooyahBg)
                        if team == wonTeam {
                            increaseWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Increase1)
                        }
                    } else if(rankCount == 2) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName2)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.SecondRankTeamBooyah)
                        nameBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2NameBg)
                        pointBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2BooyahBg)
                        if team == wonTeam {
                            increaseWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Increase2)
                        }
                    } else if(rankCount == 3) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName3)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.ThirdRankTeamBooyah)
                        nameBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3NameBg)
                        pointBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3BooyahBg)
                        if team == wonTeam {
                            increaseWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Increase3)
                        }
                    }
                    if team == player<Player>.HostTeam {
                        if rankBgWidget<UIWidgetImage>.Color != #D68E00 {
                            start globalEntity<GlobalAnimationManager>.DOChangeColor(rankBgWidget, #9C9C9C, #D68E00, 500)
                        }
                        if nameBgWidget<UIWidgetImage>.Color != #D68E00 {
                            start globalEntity<GlobalAnimationManager>.DOChangeColor(nameBgWidget, #363636, #D68E00, 500)
                        }
                        if pointBgWidget<UIWidgetImage>.Color != #D68E00 {
                            start globalEntity<GlobalAnimationManager>.DOChangeColor(pointBgWidget, #9C9C9C, #D68E00, 500)
                        }
                    } else {
                        rankBgWidget<UIWidgetImage>.Color = #9C9C9C// Set other teams to white
                        nameBgWidget<UIWidgetImage>.Color = #363636
                        pointBgWidget<UIWidgetImage>.Color = #9C9C9C
                    }
                    nameWidget<UIWidgetLabel>.Content = LocString{"TEAM", List<string>{ToString(team<Team>.TeamSeq)}} // Use localization for team names
                    if team == wonTeam {
                        start globalEntity<GlobalAnimationManager>.DOIncreaseTweenFullScoreBoard(scoreWidget, increaseWidget, scores)
                    } else {
                        scoreWidget<UIWidgetLabel>.Content = ToString(scores)
                    }
                }
            }
            rankCount = rankCount + 1;
        }
    }
    
    /*
    Updates the full scoreboard UI for all players.
    */
    func UpdateFullScoreBoard(){
        var sortedTeamList List<entity<Team>> = globalEntity<TeamData>.GetSortedTeamList()
        var rankCount int = 1
        for index, team in sortedTeamList {
            var scores = globalEntity<TeamData>.GetTeamPoint(team)
            for index, player in GetAllPlayers() {
                if(Map.ContainKey(fullScoreBoardUIDict, player)) {
                    var ui = fullScoreBoardUIDict[player]
                    var rankBgWidget  entity<UIWidget>
                    var nameWidget entity<UIWidget>
                    var scoreWidget entity<UIWidget>
                    var nameBgWidget entity<UIWidget>
                    var pointBgWidget entity<UIWidget>
                    if(rankCount == 1) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName1)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.FirstRankTeamBooyah)
                        nameBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1NameBg) 
                        pointBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1BooyahBg)
                    } else if(rankCount == 2) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName2)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.SecondRankTeamBooyah)
                        nameBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2NameBg)
                        pointBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2BooyahBg)
                    } else if(rankCount == 3) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName3)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.ThirdRankTeamBooyah)
                        nameBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3NameBg)
                        pointBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3BooyahBg)
                    }
                    if team == player<Player>.HostTeam {
                        rankBgWidget<UIWidgetImage>.Color = #D68E00// Highlight the player's team in the scoreboard
                        nameBgWidget<UIWidgetImage>.Color = #D68E00
                        pointBgWidget<UIWidgetImage>.Color = #D68E00
                    } else {
                        rankBgWidget<UIWidgetImage>.Color = #9C9C9C// Set other teams to white
                    }
                    nameWidget<UIWidgetLabel>.Content = LocString{"TEAM", List<string>{ToString(team<Team>.TeamSeq)}} // Use localization for team names
                    scoreWidget<UIWidgetLabel>.Content = ToString(scores)
                }
            }
            rankCount = rankCount + 1;
        }
    }

    /*
    Creates the round information HUD for a player.
    @param player: The player entity to create the HUD for
    */
    async func CreateRoundInfoHUD(player entity<Player>){
        var currentCount = globalEntity<CombatRoundCounter>.GetCount() // Get the current round count
        var currentStageName = globalEntity<SpawnPoints>.GetNameForStage(globalEntity<GlobalPreparationPhaseManager>.oldStagesList[List.Length(globalEntity<GlobalPreparationPhaseManager>.oldStagesList) - 1]) // Get the name of the current stage
        if !Map.ContainKey(roundInfoUIDitct, player) {
            CreateBuiltInUI(out var createdUI, player, EResInternalHud.RoundInfoHud as BuiltInUIType)
            roundInfoUIDitct[player] = createdUI as entity<UISimpleRoundStartBanner> // Associate the player with their round info UI
        }
        roundInfoUIDitct[player]<UISimpleRoundStartBanner>.RoundNumKey = LocString{"ROUND_INFO_2", List<string>{ToString(currentCount), currentStageName}}
        globalEntity<TargetAndCombatTimer>.UpdateRoundStageInfo(player, currentCount, currentStageName)
        roundInfoUIDitct[player]<UISimpleRoundStartBanner>.IsVisible = true // Set the round info UI to be visible
    WaitForMillisecond(3000)
        roundInfoUIDitct[player]<UISimpleRoundStartBanner>.IsVisible = false // Hide the round info UI after a short delay
    }

    /*
    Creates the end round HUD for a winning team.
    @param winningTeam: The winning team entity
    */
    async func CreateEndRoundHUD(winningTeam entity<Team>){
        var endRoundUIList = List<entity<UIRoundInfoBanner>>{}
        for index, player in GetAllPlayers(){
            CreateBuiltInUI(out var createdUI, player, EResInternalHud.EndRoundInfoHud as BuiltInUIType)
            createdUI<UIRoundInfoBanner>.Title = LocString{"ROUND_END_SUBTITLE", List<string>{ToString(winningTeam<Team>.TeamSeq)}}
            Append(endRoundUIList, createdUI as entity<UIRoundInfoBanner>) // Add the created UI to the list
        }
        WaitForMillisecond(2000)
        for index, endRoundUI in endRoundUIList {
            DestroyBuiltInUI(endRoundUI)
        }
    }

    /*
    Creates the last round HUD for a winning team.
    @param winningTeam: The winning team entity
    @param player: The player entity to create the HUD for
    */
    async func CreateLastRoundHUD(winningTeam entity<Team>, player entity<Player>){
        CreateBuiltInUI(out var createdUI, player, EResInternalHud.ResultBannerHud as BuiltInUIType)
        if player<Player>.HostTeam == winningTeam {
            createdUI<UIWinOrLoseBanner>.Result = GameResultType.Win // Set the result to win
        } else {
            createdUI<UIWinOrLoseBanner>.Result = GameResultType.Lose // Set the result to lose
        }
        WaitForMillisecond(5000)
        DestroyBuiltInUI(createdUI)
    }

    /*
    Creates the end game HUD for a player.
    @param player: The player entity to create the HUD for
    @param playerTeam: The team entity the player belongs to
    @param resultStatus: The result status of the game (1: Win, 2: Lose, 3: Draw)
    @param teamSorted: The list of teams sorted by their scores
    */
    func CreateEndGameHUD(player entity<Player>, playerTeam entity<Team>, resultStatus int, teamSorted List<entity<Team>>){
        CreateBuiltInUI(out var createdUI2, player, EResInternalHud.MultiTeamMatchResultHud as BuiltInUIType)
        var teamNameList = List<string>{}
        var pointList = List<int>{}
        for index, team in teamSorted {
            Append(pointList, globalEntity<TeamData>.GetTeamPoint(team))
            if team<Team>.TeamSeq == 1 {
                Append(teamNameList, LocString{"TEAM_1", List<string>{}})
            } else if team<Team>.TeamSeq == 2 {
                Append(teamNameList, LocString{"TEAM_2", List<string>{}})
            } else if team<Team>.TeamSeq == 3 {
                Append(teamNameList, LocString{"TEAM_3", List<string>{}})
            }
        }
        createdUI2<UIMultiTeamResultPanel>.MainScoreList = pointList
        createdUI2<UIMultiTeamResultPanel>.TeamRankDisplay = teamNameList    
        createdUI2<UIMultiTeamResultPanel>.PlayerRank = globalEntity<PlayerData>.GetSortedPlayerList()
        if resultStatus == 1 {
            createdUI2<UIMultiTeamResultPanel>.Result = GameResultType.Win // Set the result to win
        } else if resultStatus == 2 {
            createdUI2<UIMultiTeamResultPanel>.Result = GameResultType.Lose // Set the result to lose
        } else {
            createdUI2<UIMultiTeamResultPanel>.Result = GameResultType.Draw // Set the result to draw
        }
        var teamRankList List<entity<Entity>> = List<entity<Entity>>{}
        for index, team in teamSorted {
            Append(teamRankList, team as entity<Entity>) // Get the team's rank
        }
        createdUI2<UIMultiTeamResultPanel>.TeamRank = teamRankList // Set the player's team rank
        var titleList = List<LocString>{LocString{"MULTI_SCBOARD_KILL", List<string>{}}, LocString{"MULTI_SCBOARD_DEATH", List<string>{}}, LocString{"MULTI_SCBOARD_DMG", List<string>{}}}
        createdUI2<UIMultiTeamResultPanel>.TitleList = titleList
        var killList = List<int>{}
        var deathList = List<int>{}
        var dmgList = List<int>{}

        // Update to check
        for index, player in createdUI2<UIMultiTeamResultPanel>.PlayerRank {
            var playerData = globalEntity<PlayerData>.GetPlayerData(player)
            Append(killList, playerData[0]) // Kills
            Append(deathList, playerData[1]) // Deaths
            Append(dmgList, playerData[2]) // Damage
        }
        createdUI2<UIMultiTeamResultPanel>.Scores1 = killList
        createdUI2<UIMultiTeamResultPanel>.Scores2 = deathList
        createdUI2<UIMultiTeamResultPanel>.Scores3 = dmgList
    }

    /*
    Registers a tooltip UI for a player.
    @param player: The player entity to register the tooltip UI for
    @return: True if the registration was successful, false otherwise
    */
    func RegisterTooltipUI(player entity<Player>) bool {
        if (tooltipUIDict == nil) {
            tooltipUIDict = Map<entity<Player>, entity<BuiltInUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(tooltipUIDict, player)) {
            CreateBuiltInUI(out var tooltipUI, player, EResInternalHud.TipHud as BuiltInUIType) // Create a new tooltip UI for the player
            tooltipUI<UITweenTip>.IsVisible = false // Set the tooltip UI to be invisible initially
            tooltipUI<UITweenTip>.TipsType = 1 // Set the type of the tooltip
            tooltipUI<UITweenTip>.Description = LocString{"SCBOARD_TOOLTIP", List<string>{}} // Use localization for the tooltip description
            tooltipUIDict[player] = tooltipUI // Associate the player with their tooltip UI
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Tooltip UI already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    /*
    Enables tooltips for all players.
    */
    async func EnableTooltips(){
        for index, player in GetAllPlayers() {
            if (Map.ContainKey(tooltipUIDict, player)) {
                var tooltipUI = tooltipUIDict[player]
                tooltipUI<UITweenTip>.IsVisible = true // Set the tooltip UI to be visible
                // globalEntity<GlobalSoundManager>.PlayTooltipSfx(player)
            } else {
                RegisterTooltipUI(player);
            }
        }
        WaitForMillisecond(5000)
        for player, tooltip in tooltipUIDict {
            if (tooltip<UITweenTip>.IsVisible == true) {
                tooltip<UITweenTip>.IsVisible = false// Set the tooltip UI to be visible
            }
        }
    }

    /*
    Enables tooltip for specific player.
    */
    async func EnableTooltipForPlayer(player entity<Player>){
        if(Map.ContainKey(tooltipUIDict, player)){
            var tooltipUI = tooltipUIDict[player]
            tooltipUI<UITweenTip>.IsVisible = true
        } else {
            RegisterTooltipUI(player);
        }
        WaitForMillisecond(5000)
        if(tooltipUIDict[player]<UITweenTip>.IsVisible == true) {
            tooltipUIDict[player]<UITweenTip>.IsVisible = false
        }
    }

    /* Unregister player from all registered UIs
    @param player The player entity to unregister
    @return void
    */
    func UnregisterAllUIs(player entity<Player>){
        globalEntity<TargetAndCombatTimer>.UnregisterGameInfo(player)
        globalEntity<PlayersTimerUI>.UnRegisterTimerUI(player)
        globalEntity<PlayersTutorial>.UnRegisterPlayer(player)
        globalEntity<PlayersShopIcon>.UnregisterShopIcon(player)
        globalEntity<TargetAndCombatTimer>.UnregisterGameInfo(player)
        if (Map.ContainKey(tooltipUIDict, player)) {
            DestroyBuiltInUI(tooltipUIDict[player]) // Destroy the tooltip UI
            Map.Remove(tooltipUIDict, player) // Remove the tooltip UI from the dictionary after destroying it
        }
        if (Map.ContainKey(fullScoreBoardUIDict, player)) {
            DestroyCustomUI(fullScoreBoardUIDict[player]) // Destroy the full scoreboard UI
            Map.Remove(fullScoreBoardUIDict, player) // Remove the full scoreboard UI from the dictionary after destroying it
        }
        if Map.ContainKey(roundInfoUIDitct, player) {
            DestroyBuiltInUI(roundInfoUIDitct[player]) // Destroy the round info UI
            Map.Remove(roundInfoUIDitct, player) // Remove the round info UI from the dictionary after destroying it
        }
        if Map.ContainKey(miniScoreBoardUIdict, player) {
            DestroyCustomUI(miniScoreBoardUIdict[player]) // Destroy the mini scoreboard UI
            Map.Remove(miniScoreBoardUIdict, player) // Remove the mini scoreboard UI from the dictionary after destroying it
        }
    }

    /* Create a 5 seconds countdown HUD for the player
    This function creates a countdown HUD that is displayed for 5 seconds before the game starts.
    @param player The player entity to create the HUD for
    @param beginPhaseDuration The duration of the beginning phase
    */
    async func Enable5sCountdownHUD(player entity<Player>) {
        CreateBuiltInUI(out var createdUI, player, EResInternalHud.FiveSecondCountDownHud as BuiltInUIType) // Create a 5 seconds countdown HUD for the player
        createdUI<UICountDown5>.LocalPosition = Vector3{0, -100, 0}
        createdUI<UICountDown5>.IsVisible = true
        NotifyPlaySoundV2(player, EResSound.FIVE_SEC_COUNT_DOWN as AudioID, 1.0)
        WaitForMillisecond(5000)
        DestroyBuiltInUI(createdUI) // Destroy the countdown HUD after 5 seconds
    }

    /*
    Create a 5 secs countdown HUD after the time delay.
    @param player The player entity to create the HUD for
    @param delay The delay before creating the HUD
    */
    async func CreateDelay5sCountDownHUD(player entity<Player>, delay int) {
        WaitForMillisecond(delay)
        CreateBuiltInUI(out var createdUI, player, EResInternalHud.FiveSecondCountDownHud as BuiltInUIType) // Create a 5 seconds countdown HUD for the player
        createdUI<UICountDown5>.LocalPosition = Vector3{0, -100, 0}
        createdUI<UICountDown5>.IsVisible = true
        NotifyPlaySoundV2(player, EResSound.FIVE_SEC_COUNT_DOWN as AudioID, 1.0)
        WaitForMillisecond(5000)
        DestroyBuiltInUI(createdUI) // Destroy the countdown HUD after 5 seconds
    }
}

// DEPRECATED FUNCTION. THEY ARE KEEP IN CASE OF EXTENDING GAME MODE IF NEEDED
// func UpdatePlayersInScoreBoard(sortedTeamList List<entity<Team>>) {
    // Clear all names first
    // for player, ui in fullScoreBoardUIDict{
    //     var foo int = 1
    //     while foo <= 3 {
    //         var teamWidget entity<UIWidget>
    //         if foo == 1 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
    //         } else if foo == 2 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
    //         } else if foo == 3 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
    //         }
    //         var nameWidgetList = GetChildren(teamWidget)
    //         for index, nameWidget in nameWidgetList {
    //             var textWidget = nameWidget<UIWidgetLabel>
    //             if textWidget<UIWidgetLabel>.Content != " " {
    //                 textWidget<UIWidgetLabel>.Content = " " // Clear the content of the name widget
    //             } else {
    //                 break;
    //             }
    //         }
    //         foo = foo + 1
    //     }
    //     var rankCount int = 1
    //     for index, team in sortedTeamList {
    //         var teamWidget entity<UIWidget>
    //         // if team<Team>.TeamSeq == 1 {
    //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
    //         // } else if team<Team>.TeamSeq == 2 {
    //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
    //         // } else if team<Team>.TeamSeq == 3 {
    //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
    //         // }
    //         if rankCount == 1{
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
    //         } else if rankCount == 2 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
    //         } else if rankCount == 3 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
    //         }
    //         var nameWidgetList = GetChildren(teamWidget)
    //         for index, player in team<Team>.AllTeammates {
    //             for index, nameWidget in nameWidgetList {
    //                 var textWidget = nameWidget<UIWidgetLabel>
    //                 if textWidget<UIWidgetLabel>.Content == " " {
    //                     textWidget<UIWidgetLabel>.Content = player<Player>.NickName// Set the player's name in the scoreboard
    //                     break;
    //                 }
    //             }
    //         }
    //         rankCount = rankCount + 1
    //     }
    // }
// }