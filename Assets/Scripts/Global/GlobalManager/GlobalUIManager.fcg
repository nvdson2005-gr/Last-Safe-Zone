import "Workflow.fcc" as Workflow
import "Playable.fcc" as Playable
import "Animation.fcc" as Animation
import "Combat.fcc" as Combat
import "../GlobalManager/GlobalSoundManager.fcg" as GlobalSoundManager
import "../GlobalManager/GlobalAnimationManager.fcg" as GlobalAnimationManager
/*
Global UI Manager
Handles all UI-related functionalities and interactions for the game.
*/
import "Math.fcc" as Math
import "Player.fcc" as Player
import "LevelObject.fcc" as LevelObject
import "Hostility.fcc" as Hostility
import "Database.fcc" as Database
import "Convert.fcc" as Convert
import "List.fcc" as List
import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Hud.fcc" as Hud
import "Map.fcc" as Map
import "../GlobalData/TeamPoints.fcg" as TeamPoints
import "../GlobalData/TeamData.fcg" as TeamData
import "../GlobalData/CombatRoundCounter.fcg" as CombatRoundCounter
import "../GlobalData/SpawnPoints.fcg" as SpawnPoints
import "../GlobalManager/GlobalPreparationPhaseManager.fcg" as GlobalPreparationPhaseManager
import "../GlobalData/TargetAndCombatTimer.fcg" as TargetAndCombatTimer
import "../GlobalData/PlayersTimerUI.fcg" as PlayersTimerUI
import "../GlobalData/PlayersTutorial.fcg" as PlayersTutorial
import "../GlobalData/PlayersShopIcon.fcg" as PlayersShopIcon
import Res from "EditorGenLib.fcc"

graph GlobalUIManager {
    fullScoreBoardUIDict Map<entity<Player>, entity<CustomUI>> // Map to associate players with their full scoreboard UIs
    miniScoreBoardUIdict Map<entity<Player>, entity<CustomUI>> // Map to associate players with their mini scoreboard UIs
    tooltipUIDict Map<entity<Player>, entity<BuiltInUI>> // Map to associate players with their tooltip UIs
    roundInfoUIDitct Map<entity<Player>, entity<UISimpleRoundStartBanner>> // Map to associate players with their round info UIs

    // Init when the game starts
    event OnAwake() {
        miniScoreBoardUIdict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map of players' mini scoreboards at the start of the game
        fullScoreBoardUIDict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map of players' full scoreboards at the start of the game
        tooltipUIDict = Map<entity<Player>, entity<UISimpleRoundStartBanner>>{} // Initialize the map of players' tooltip UIs at the start of the game
        roundInfoUIDitct = Map<entity<Player>, entity<UISimpleRoundStartBanner>>{} // Initialize the map of players' round info UIs at the start of the game
    }

    /*
    Creates the global opening HUD for a player.
    @param player: The player entity to create the HUD for
    */
    async func CreateGlobalOpeningHUD(player entity<Player>){
        if globalEntity<Global>.CurrentPhaseIndex == EPhase.Preparation || globalEntity<Global>.CurrentPhaseIndex == EPhase.Start{
            CreateBuiltInUI(out var createdHUD, player, EResInternalHud.OpeningBannerHud as BuiltInUIType)
            createdHUD<UIOpeningBanner>.Title = LocString{"GAME_NAME", List<string>{}}
            createdHUD<UIOpeningBanner>.Description = LocString{"GAME_DESCRIPTION", List<string>{}}
            createdHUD<UIOpeningBanner>.Icon = EResSprite.logo
            WaitForMillisecond(8000)
            DestroyBuiltInUI(createdHUD)
        }
    }

    /*
    Registers the mini scoreboard UI for a player.
    @param player: The player entity to register the mini scoreboard for
    @return: True if the registration was successful, false otherwise
    */
    func RegisterMiniScoreBoard(player entity<Player>) bool {
        CreateCustomUI(out var miniScoreBoard, player, EResUI.MiniScoreBoardUI);
        if (miniScoreBoardUIdict == nil) { miniScoreBoardUIdict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(miniScoreBoardUIdict, player)) {
            miniScoreBoardUIdict[player] = miniScoreBoard // Associate the player with their mini scoreboard
            var playersTeam entity<Team> = player<Player>.HostTeam
            // var playersTeam entity<Team> = nil
            // for index, team in GetAllTeams() {
            //     for index, member in team<Team>.AllTeammates {
            //         if member == player {
            //             playersTeam = team
            //             break
            //         }
            //     }
            //     if playersTeam != nil {
            //         break
            //     }
            // }
            var w entity<UIWidget>
            var scoreW entity<UIWidget>
            var aliveWidget entity<UIWidget>
            if(playersTeam<Team>.TeamSeq == 1) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1ScoreBG as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team1AlivesLayout as CustomUIWidgetID)
            } else if(playersTeam<Team>.TeamSeq == 2) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2ScoreBG as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team2AlivesLayout as CustomUIWidgetID)
            } else if(playersTeam<Team>.TeamSeq == 3) {
                w= GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3Bg as CustomUIWidgetID)
                scoreW = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3ScoreBg as CustomUIWidgetID)
                aliveWidget = GetWidgetFromCustomUI(player, miniScoreBoard, EResUIMiniScoreBoardUI.Team3AlivesLayout as CustomUIWidgetID)
            }
            if(w== nil) {
                LogError("<GlobalUIManager.fcg>: Failed to get widget for player: " + player<Entity>.Name) // Error Info
                return false;
            }
            var aliveWidgetList = GetChildren(aliveWidget)
            // LogError(aliveWidgetList)
            w<UIWidgetImage>.Color = #FFB400
            // scoreW<UIWidgetImage>.Color = #FFB400
            for index, widget in aliveWidgetList {
                widget<UIWidgetImage>.Color = #FFB400
                // widget<UIWidget>.Active = false
            }
            // LogInfo("<GlobalUIManager.fcg>: Registered mini scoreboard for player: " + player<Entity>.Name) // Debug Info
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Mini scoreboard already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    async func CreatePlusAnimation(winningTeam entity<Team>){
        for index, player in GetAllPlayers() {
            var widget entity<UIWidget>
            if winningTeam<Team>.TeamSeq == 1 {
                widget = GetWidgetFromCustomUI(player, miniScoreBoardUIdict[player], EResUIMiniScoreBoardUI.TextAnimTeam1 as CustomUIWidgetID)
            } else if winningTeam<Team>.TeamSeq == 2 {
                widget = GetWidgetFromCustomUI(player, miniScoreBoardUIdict[player], EResUIMiniScoreBoardUI.TextAnimTeam2 as CustomUIWidgetID)
            } else if winningTeam<Team>.TeamSeq == 3 {
                widget = GetWidgetFromCustomUI(player, miniScoreBoardUIdict[player], EResUIMiniScoreBoardUI.TextAnimTeam3 as CustomUIWidgetID)
            }
            start globalEntity<GlobalAnimationManager>.DOIncreaseTween(widget) // Start the increase tween animation for the widget
        }
    }
    // Update mini scoreboard, including team points and current alives in each team
    func UpdateMiniScoreboard(){
        for index, team in GetAllTeams() {
            var point = globalEntity<TeamData>.GetTeamPoint(team)
            var aliveCount = 0
            for index, player in team<Team>.AllTeammates {
                if player<Player>.HP > 0 {
                    aliveCount = aliveCount + 1
                }
            }
            for index, player in GetAllPlayers() {
                if(Map.ContainKey(miniScoreBoardUIdict, player)) {
                    var ui = miniScoreBoardUIdict[player]
                    var widget entity<UIWidget>
                    var alivesWidget entity<UIWidget>
                    if(team<Team>.TeamSeq == 1) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team1Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team1AlivesLayout as CustomUIWidgetID)
                    } else if(team<Team>.TeamSeq == 2) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team2Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team2AlivesLayout as CustomUIWidgetID)
                    } else if(team<Team>.TeamSeq == 3) {
                        widget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team3Score as CustomUIWidgetID)
                        alivesWidget = GetWidgetFromCustomUI(player, ui, EResUIMiniScoreBoardUI.Team3AlivesLayout as CustomUIWidgetID)
                    } 
                    widget<UIWidgetLabel>.Content = ToString(point) 
                    var aliveWidgetList = GetChildren(alivesWidget)
                    for index, widget in aliveWidgetList {
                        if index >= aliveCount {
                            widget<UIWidget>.Active = false // Hide the widget if the index is greater than or equal to the alive count
                            // SetActive(widget, false) // Hide the widget if the index is greater than or equal to the alive count
                        } else {
                            widget<UIWidget>.Active = true // Show the widget if the index is less than the alive count
                        }
                    }
                }
            }
        }
    }

    /*
    Registers the full scoreboard UI for a player.
    @param player: The player entity to register the full scoreboard for
    @return: True if the registration was successful, false otherwise
    */
    func RegisterFullScoreBoard(player entity<Player>) bool {
        CreateCustomUI(out var fullScoreBoard, player, EResUI.FullScoreBoard);
        if (fullScoreBoardUIDict == nil) { fullScoreBoardUIDict = Map<entity<Player>, entity<CustomUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(fullScoreBoardUIDict, player)) {
            fullScoreBoardUIDict[player] = fullScoreBoard // Associate the player with their full scoreboard
            // LogInfo("<GlobalUIManager.fcg>: Registered full scoreboard for player: " + player<Entity>.Name) // Debug Info
            var playerTeam = player<Player>.HostTeam
            var teamWidget entity<UIWidget>
            if playerTeam<Team>.TeamSeq == 1 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank1BG)
            } else if playerTeam<Team>.TeamSeq == 2 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank2BG)
            } else if playerTeam<Team>.TeamSeq == 3 {
                teamWidget = GetWidgetFromCustomUI(player, fullScoreBoard, EResUIFullScoreBoard.Rank3BG)
            }
            teamWidget<UIWidgetImage>.Color = #FFB400 // Set the color of the team widget to a specific color
            fullScoreBoard<CustomUI>.IsVisible = false // Initially set the full scoreboard to not visible
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Full scoreboard already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    /*
    Sets the visibility of the full scoreboard for a player.
    @param player: The player entity to set the visibility for
    @param isVisible: The visibility state to set
    */
    func SetVisibilityFullScoreBoard(player entity<Player>, isVisible bool) {
        if (Map.ContainKey(fullScoreBoardUIDict, player)) {
            fullScoreBoardUIDict[player]<CustomUI>.IsVisible = isVisible
        }
    }

    /*
    Updates the full scoreboard UI for all players.
    */
    func UpdateFullScoreBoard(){
        var sortedTeamList List<entity<Team>> = globalEntity<TeamData>.GetSortedTeamList()
        var rankCount int = 1
        for index, team in sortedTeamList {
            var scores = globalEntity<TeamData>.GetTeamPoint(team)
            for index, player in GetAllPlayers() {
                if(Map.ContainKey(fullScoreBoardUIDict, player)) {
                    var ui = fullScoreBoardUIDict[player]
                    var rankBgWidget  entity<UIWidget>
                    var nameWidget entity<UIWidget>
                    var scoreWidget entity<UIWidget>
                    if(rankCount == 1) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank1BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName1)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.FirstRankTeamBooyah)
                    } else if(rankCount == 2) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank2BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName2)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.SecondRankTeamBooyah)
                    } else if(rankCount == 3) {
                        rankBgWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.Rank3BG)
                        nameWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamName3)
                        scoreWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.ThirdRankTeamBooyah)
                    }
                    // if team<Team>.TeamSeq == 1{
                    //     // nameWidget<UIWidgetLabel>.Content = "Team 1"
                    //     // nameWidget<UIWidgetLabel>.Content = LocString{"TEAM_1", List<string>{}} // Use localization for team names
                    // } else if team<Team>.TeamSeq == 2 {
                    //     // nameWidget<UIWidgetLabel>.Content = "Team 2"
                    //     // nameWidget<UIWidgetLabel>.Content = LocString{"TEAM_2", List<string>{}} // Use localization for team names
                    // } else if team<Team>.TeamSeq == 3 {
                    //     // nameWidget<UIWidgetLabel>.Content = "Team 3"
                    //     // nameWidget<UIWidgetLabel>.Content = LocString{"TEAM_3", List<string>{}} // Use localization for team names
                    // }
                    if team == player<Player>.HostTeam {
                        rankBgWidget<UIWidgetImage>.Color = #FFB400 // Highlight the player's team in the scoreboard
                    } else {
                        rankBgWidget<UIWidgetImage>.Color = #9C9C9C// Set other teams to white
                    }
                    nameWidget<UIWidgetLabel>.Content = LocString{"TEAM", List<string>{ToString(team<Team>.TeamSeq)}} // Use localization for team names
                    scoreWidget<UIWidgetLabel>.Content = ToString(scores)
                }
            }
            rankCount = rankCount + 1;
        }
    }

    /*
    Creates the round information HUD for a player.
    @param player: The player entity to create the HUD for
    */
    async func CreateRoundInfoHUD(player entity<Player>){
        var currentCount = globalEntity<CombatRoundCounter>.GetCount() // Get the current round count
        var currentStageName = globalEntity<SpawnPoints>.GetNameForStage(globalEntity<GlobalPreparationPhaseManager>.oldStagesList[List.Length(globalEntity<GlobalPreparationPhaseManager>.oldStagesList) - 1]) // Get the name of the current stage
        if !Map.ContainKey(roundInfoUIDitct, player) {
            CreateBuiltInUI(out var createdUI, player, EResInternalHud.RoundInfoHud as BuiltInUIType)
            roundInfoUIDitct[player] = createdUI as entity<UISimpleRoundStartBanner> // Associate the player with their round info UI
        }
        roundInfoUIDitct[player]<UISimpleRoundStartBanner>.RoundNumKey = LocString{"ROUND_INFO", List<string>{ToString(currentCount), currentStageName}}
        globalEntity<TargetAndCombatTimer>.UpdateRoundStageInfo(player, currentCount, currentStageName)
        roundInfoUIDitct[player]<UISimpleRoundStartBanner>.IsVisible = true // Set the round info UI to be visible
    WaitForMillisecond(3000)
        roundInfoUIDitct[player]<UISimpleRoundStartBanner>.IsVisible = false // Hide the round info UI after a short delay
    }

    /*
    Creates the end round HUD for a winning team.
    @param winningTeam: The winning team entity
    */
    async func CreateEndRoundHUD(winningTeam entity<Team>){
        var endRoundUIList = List<entity<UIRoundInfoBanner>>{}
        for index, player in GetAllPlayers(){
            CreateBuiltInUI(out var createdUI, player, EResInternalHud.EndRoundInfoHud as BuiltInUIType)
            createdUI<UIRoundInfoBanner>.Title = LocString{"ROUND_END_INFO", List<string>{}}
            // createdUI<UIRoundInfoBanner>.SubTitle = "Team " + winningTeam<Team>.TeamSeq + " wins the round!"
            createdUI<UIRoundInfoBanner>.SubTitle = LocString{"ROUND_END_SUBTITLE", List<string>{ToString(winningTeam<Team>.TeamSeq)}}
            Append(endRoundUIList, createdUI as entity<UIRoundInfoBanner>) // Add the created UI to the list
        }
        WaitForMillisecond(2000)
        for index, endRoundUI in endRoundUIList {
            DestroyBuiltInUI(endRoundUI)
        }
    }

    /*
    Creates the last round HUD for a winning team.
    @param winningTeam: The winning team entity
    @param player: The player entity to create the HUD for
    */
    async func CreateLastRoundHUD(winningTeam entity<Team>, player entity<Player>){
        CreateBuiltInUI(out var createdUI, player, EResInternalHud.ResultBannerHud as BuiltInUIType)
        if player<Player>.HostTeam == winningTeam {
            createdUI<UIWinOrLoseBanner>.Result = GameResultType.Win // Set the result to win
        } else {
            createdUI<UIWinOrLoseBanner>.Result = GameResultType.Lose // Set the result to lose
        }
        WaitForMillisecond(5000)
        DestroyBuiltInUI(createdUI)
    }

    /*
    Creates the end game HUD for a player.
    @param player: The player entity to create the HUD for
    @param playerTeam: The team entity the player belongs to
    @param resultStatus: The result status of the game (1: Win, 2: Lose, 3: Draw)
    @param teamSorted: The list of teams sorted by their scores
    */
    func CreateEndGameHUD(player entity<Player>, playerTeam entity<Team>, resultStatus int, teamSorted List<entity<Team>>){
        CreateBuiltInUI(out var createdUI2, player, EResInternalHud.MultiTeamMatchResultHud as BuiltInUIType)
        var teamNameList = List<string>{}
        var pointList = List<int>{}
        for index, team in teamSorted {
            Append(pointList, globalEntity<TeamData>.GetTeamPoint(team))
            if team<Team>.TeamSeq == 1 {
                Append(teamNameList, LocString{"TEAM_1", List<string>{}})
            } else if team<Team>.TeamSeq == 2 {
                Append(teamNameList, LocString{"TEAM_2", List<string>{}})
            } else if team<Team>.TeamSeq == 3 {
                Append(teamNameList, LocString{"TEAM_3", List<string>{}})
            }
        }
        createdUI2<UIMultiTeamResultPanel>.MainScoreList = pointList
        createdUI2<UIMultiTeamResultPanel>.TeamRankDisplay = teamNameList    
        createdUI2<UIMultiTeamResultPanel>.PlayerRank = GetAllPlayers() // No info in docs about this. Just know that it works by getting all players into this list lmao
        // createdUI2<UIMultiTeamResultPanel>.ShowGift = true
        // createdUI2<UIMultiTeamResultPanel>.ShowReplay = true
        // createdUI2<UIMultiTeamResultPanel>.ShowReport = true
        // createdUI2<UIMultiTeamResultPanel>.ShowShare = true
        // createdUI2<UIMultiTeamResultPanel>.ShowLobby = true
        // createdUI2<UIMultiTeamResultPanel>.ShowLike = true
        // createdUI2<UIMultiTeamResultPanel>.ShowAddFriend = true
        if resultStatus == 1 {
            createdUI2<UIMultiTeamResultPanel>.Result = GameResultType.Win // Set the result to win
        } else if resultStatus == 2 {
            createdUI2<UIMultiTeamResultPanel>.Result = GameResultType.Lose // Set the result to lose
        } else {
            createdUI2<UIMultiTeamResultPanel>.Result = GameResultType.Draw // Set the result to draw
        }
        // var playerTeamList List<List<entity<Player>>> = List<List<entity<Player>>>{}
        // for index, team in teamSorted {
        //     Append(playerTeamList, team<Team>.AllTeammates) // Get all players in each team
        // }
        var teamRankList List<entity<Entity>> = List<entity<Entity>>{}
        for index, team in teamSorted {
            Append(teamRankList, team as entity<Entity>) // Get the team's rank
        }
        createdUI2<UIMultiTeamResultPanel>.TeamRank = teamRankList // Set the player's team rank
    }

    /*
    Registers a tooltip UI for a player.
    @param player: The player entity to register the tooltip UI for
    @return: True if the registration was successful, false otherwise
    */
    func RegisterTooltipUI(player entity<Player>) bool {
        if (tooltipUIDict == nil) {
            tooltipUIDict = Map<entity<Player>, entity<BuiltInUI>>{} // Initialize the map if it is null
        }
        if (!Map.ContainKey(tooltipUIDict, player)) {
            CreateBuiltInUI(out var tooltipUI, player, EResInternalHud.TipHud as BuiltInUIType) // Create a new tooltip UI for the player
            tooltipUI<UITweenTip>.IsVisible = false // Set the tooltip UI to be invisible initially
            tooltipUI<UITweenTip>.TipsType = 1 // Set the type of the tooltip
            tooltipUI<UITweenTip>.Description = LocString{"SCBOARD_TOOLTIP", List<string>{}} // Use localization for the tooltip description
            tooltipUIDict[player] = tooltipUI // Associate the player with their tooltip UI
            return true // Return true to indicate the operation was successful
        } else {
            LogWarning("<GlobalUIManager.fcg>: Tooltip UI already registered for player: " + player<Entity>.Name) // Warning Info
            return false // Return false to indicate the operation was unsuccessful
        }
    }

    /*
    Enables tooltips for all players.
    */
    async func EnableTooltips(){
        for index, player in GetAllPlayers() {
            if (Map.ContainKey(tooltipUIDict, player)) {
                var tooltipUI = tooltipUIDict[player]
                tooltipUI<UITweenTip>.IsVisible = true // Set the tooltip UI to be visible
                // globalEntity<GlobalSoundManager>.PlayTooltipSfx(player)
            } else {
                RegisterTooltipUI(player);
            }
        }
        WaitForMillisecond(5000)
        for player, tooltip in tooltipUIDict {
            if (tooltip<UITweenTip>.IsVisible == true) {
                tooltip<UITweenTip>.IsVisible = false// Set the tooltip UI to be visible
            }
        }
    }

    /* Unregister player from all registered UIs
    @param player The player entity to unregister
    @return void
    */
    func UnregisterAllUIs(player entity<Player>){
        globalEntity<TargetAndCombatTimer>.UnregisterGameInfo(player)
        globalEntity<PlayersTimerUI>.UnRegisterTimerUI(player)
        globalEntity<PlayersTutorial>.UnRegisterPlayer(player)
        globalEntity<PlayersShopIcon>.UnregisterShopIcon(player)
        if (Map.ContainKey(tooltipUIDict, player)) {
            DestroyBuiltInUI(tooltipUIDict[player]) // Destroy the tooltip UI
            Map.Remove(tooltipUIDict, player) // Remove the tooltip UI from the dictionary after destroying it
        }
        if (Map.ContainKey(fullScoreBoardUIDict, player)) {
            DestroyCustomUI(fullScoreBoardUIDict[player]) // Destroy the full scoreboard UI
            Map.Remove(fullScoreBoardUIDict, player) // Remove the full scoreboard UI from the dictionary after destroying it
        }
        if Map.ContainKey(roundInfoUIDitct, player) {
            DestroyBuiltInUI(roundInfoUIDitct[player]) // Destroy the round info UI
            Map.Remove(roundInfoUIDitct, player) // Remove the round info UI from the dictionary after destroying it
        }
        if Map.ContainKey(miniScoreBoardUIdict, player) {
            DestroyCustomUI(miniScoreBoardUIdict[player]) // Destroy the mini scoreboard UI
            Map.Remove(miniScoreBoardUIdict, player) // Remove the mini scoreboard UI from the dictionary after destroying it
        }
    }

    /* Create a 5 seconds countdown HUD for the player
    This function creates a countdown HUD that is displayed for 5 seconds before the game starts.
    @param player The player entity to create the HUD for
    @param beginPhaseDuration The duration of the beginning phase
    */
    async func Enable5sCountdownHUD(player entity<Player>) {
        CreateBuiltInUI(out var createdUI, player, EResInternalHud.FiveSecondCountDownHud as BuiltInUIType) // Create a 5 seconds countdown HUD for the player
        createdUI<UICountDown5>.LocalPosition = Vector3{0, -100, 0}
        createdUI<UICountDown5>.IsVisible = true
        NotifyPlaySoundV2(player, EResSound.FIVE_SEC_COUNT_DOWN as AudioID, 1.0)
        WaitForMillisecond(5000)
        DestroyBuiltInUI(createdUI) // Destroy the countdown HUD after 5 seconds
    }
}

// DEPRECATED FUNCTION. THEY ARE KEEP IN CASE OF EXTENDING GAME MODE IF NEEDED
// func UpdatePlayersInScoreBoard(sortedTeamList List<entity<Team>>) {
    // Clear all names first
    // for player, ui in fullScoreBoardUIDict{
    //     var foo int = 1
    //     while foo <= 3 {
    //         var teamWidget entity<UIWidget>
    //         if foo == 1 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
    //         } else if foo == 2 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
    //         } else if foo == 3 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
    //         }
    //         var nameWidgetList = GetChildren(teamWidget)
    //         for index, nameWidget in nameWidgetList {
    //             var textWidget = nameWidget<UIWidgetLabel>
    //             if textWidget<UIWidgetLabel>.Content != " " {
    //                 textWidget<UIWidgetLabel>.Content = " " // Clear the content of the name widget
    //             } else {
    //                 break;
    //             }
    //         }
    //         foo = foo + 1
    //     }
    //     var rankCount int = 1
    //     for index, team in sortedTeamList {
    //         var teamWidget entity<UIWidget>
    //         // if team<Team>.TeamSeq == 1 {
    //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
    //         // } else if team<Team>.TeamSeq == 2 {
    //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
    //         // } else if team<Team>.TeamSeq == 3 {
    //         //     teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
    //         // }
    //         if rankCount == 1{
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames1)
    //         } else if rankCount == 2 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames2)
    //         } else if rankCount == 3 {
    //             teamWidget = GetWidgetFromCustomUI(player, ui, EResUIFullScoreBoard.TeamNames3)
    //         }
    //         var nameWidgetList = GetChildren(teamWidget)
    //         for index, player in team<Team>.AllTeammates {
    //             for index, nameWidget in nameWidgetList {
    //                 var textWidget = nameWidget<UIWidgetLabel>
    //                 if textWidget<UIWidgetLabel>.Content == " " {
    //                     textWidget<UIWidgetLabel>.Content = player<Player>.NickName// Set the player's name in the scoreboard
    //                     break;
    //                 }
    //             }
    //         }
    //         rankCount = rankCount + 1
    //     }
    // }
// }