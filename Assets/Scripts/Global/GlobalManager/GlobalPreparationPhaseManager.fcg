/* 
Global Preparation Phase Manager
Handles all the neccessary actions in Before Combat phase, including setting all necessary player states
together with teleport players to their designated starting positions.
*/
import "StdLibrary.fcc" as StdLib
import "EditorGenLib.fcc" as EditorLib
import "Player.fcc" as Player
import "Workflow.fcc" as Workflow
import "../GlobalData/PlayersTimerUI.fcg" as PlayersTimerUI
import "Collection.fcc" as Collection
import "../GlobalData/SpawnPoints.fcg" as SpawnPoints
import "Math.fcc" as Math
import "Strings.fcc" as Strings
import "List.fcc" as List
import "../GlobalData/PlayersShopIcon.fcg" as PlayersShopIcon
import "../GlobalManager/GlobalGameManager.fcg" as GlobalGameManager
import "Items.fcc" as Items
import "../GlobalData/CombatRoundCounter.fcg" as CombatRoundCounter
import "../../Player/PlayerController.fcg" as PlayerController
import "../GlobalManager/GlobalUIManager.fcg" as GlobalUIManager
import "../GlobalData/TeamData.fcg" as TeamData
import "../GlobalData/GlobalSafeZones.fcg" as GlobalSafeZones
import "SafeZone.fcc" as SafeZone
import "../GlobalManager/GlobalSoundManager.fcg" as GlobalSoundManager
import "Convert.fcc" as Convert

graph GlobalPreparationPhaseManager {
    // Script variable storing the old stage index
    oldStageIndex int
    oldStagesList List<int> = List<int>{} // List to store old stages (up to 4 stages)

    // When the preparation phase starts, get a random stage index and init data for players
    event OnPhaseStart(phase entity<Phase>) {
        if phase<Phase>.Index == EPhase.__Before6Combat__ {
            // Before combat, get a random sage index
            var randomStageIndex = RandomStage(oldStageIndex)
            // Memorize the old stage index 
            // oldStageIndex = randomStageIndex
            Append(oldStagesList, randomStageIndex)
            if List.Length(oldStagesList) > 4 {
                RemoveAt(oldStagesList, 0) // Keep only the last 4 stages
            }
            // LogInfo("<GlobalPreparationPhaseManager.fcg>: Starting Preparation Phase. Init necessary data...") // Debug Info

            // Initialize data before combat
            wait InitDataBeforeCombat(phase<Phase>.Duration, randomStageIndex); 
        }
    }

    // event OnPhaseEnd(phase entity<Phase>) {
    //     if phase<Phase>.Index == EPhase.Preparation{
    //         // wait globalEntity<GlobalUIManager>.CreateRoundInfoHUD(); // Create the round info HUD for all players
    //     }
    // }

    /*
    Sets a delay for the player's gravity to be zero, then restores it after the delay.
    @param player: The player entity to set the gravity delay for
    @param delay: The duration of the delay in milliseconds
    */
    async func SetGravityDelay(player entity<Player>, delay int) {
        player<Player>.Gravity = 0
        WaitForMillisecond(delay)
        player<Player>.Gravity = -9.81
    }

    // UTILS 
    /* Initialize data before combat
    This function sets up all necessary data and states for players before the combat phase begins.
    More detail inside the function implementation.
    @param duration: The duration of Before Combat phase
    @param randomStageIndex: The random stage index for the current round
    */
    async func InitDataBeforeCombat(duration int, randomStageIndex int) {
        // LogError(globalEntity<TeamData>.GetSortedTeamList()); // Debug Info
        // Enable a tooltip for user to know how to get the full scoreboard
        globalEntity<CombatRoundCounter>.IncreaseCount(); // Increment the round counter
        if globalEntity<CombatRoundCounter>.GetCount() == 0 {
            // globalEntity<GlobalUIManager>.UpdatePlayersInScoreBoard(GetAllTeams()); // Set up the full scoreboard UI for all players
        }   
        // Initialize player states
        for index, player in GetAllPlayers() {
            start SetGravityDelay(player, 500) // Set the player's gravity to zero for a short delay
            ResetSkill(player); // Reset the player's skills
            ReaddAttachment(player); // Re-add attachments to the player
            player<PlayerController>.SetZeroGravityStatus(player, false); // Set back the gravity for the player
            start globalEntity<PlayersTimerUI>.SetPlayerTimer(player, duration); // Set the player's timer
            globalEntity<PlayersTimerUI>.SetTimerVisibility(true); // Set the timer visibility to true
            SetInvincibilityStatus(player, true); // Set the invincibility status for the player
            // player<PlayerController>.AddMedKitEachRound(player); // Add Med Kit in each round
            start globalEntity<GlobalUIManager>.CreateRoundInfoHUD(player)
            start globalEntity<GlobalSoundManager>.PlayFiveSecSfx(player, duration - 5000)
        }

        // Update mini score board to init current alives, and team points
        globalEntity<GlobalUIManager>.UpdateMiniScoreboard();

        globalEntity<PlayersShopIcon>.ToggleAllIcons(true) // Show all players' shop icons
        InitPlayerWeapons(); // Initialize player weapons
        LogWarning("Available Stages: " + globalEntity<GlobalGameManager>.availableStages + " - Chosen stage index " + randomStageIndex); // Debug Info
        var spawnPositions = globalEntity<SpawnPoints>.GetSpawnPositionForRound(randomStageIndex) // Get all spawn positions from the scene
        globalEntity<SpawnPoints>.SetSpawnPointsActiveStatusForRound(randomStageIndex, true); // Activate spawn points of the current stage

        for index, team in GetAllTeams() {
            var randomIndex = RandomInt(0, List.Length(spawnPositions)) // Get a random index in spawn list
            var randomPosition = spawnPositions[randomIndex] // Get the random spawn position
            // Use a loop to make sure all players in the team are teleported to the same position
            for index, player in team<Team>.AllTeammates {
                ReviveAtNextFrame(player) // Revive the player at the next frame
                Teleport(player, randomPosition, Vector3{0, 0, 0}) // Teleport the player to the random position
            }
            RemoveAt(spawnPositions, randomIndex) // Remove the used spawn position from the list
        }
        globalEntity<GlobalSafeZones>.OpenSafeZone(randomStageIndex); // Open the safe zone for the current round

        WaitForMillisecond(duration) // Wait for the specified duration

        start globalEntity<GlobalUIManager>.EnableTooltips(); // Enable tooltips to warn about fast shrinking safe zone
        // globalEntity<PlayersTimerUI>.SetTimerVisibility(false); // Hide the timer UI after the preparation phase
        // EnableMovingSafeZone(Vector3{230, 9, -102}, Vector3{234, 5, -88}, 30, 0.5, 45, 40)
        // When the round starts, reset player states
        for index, player in GetAllPlayers() {
            player<Player>.EP = 200; // Set player's initial EP to 200 every round
            SetInvincibilityStatus(player, false); // Disable invincibility for all players
            SetInvincibility(player, 5); // 5 secs of invincibility
        }
        globalEntity<PlayersShopIcon>.ToggleAllIcons(false); // Hide all players' shop icons
        globalEntity<SpawnPoints>.SetSpawnPointsActiveStatusForRound(randomStageIndex, false); // Disable all spawn points
    }

    /* Set Invincibility Status for a player (NO DURATION, TO SET INVINCIBLE WITH DURATION USE SetInvincibility() from Player.fcc library)
    @param player The player entity
    @param invincible The invincibility status to set
    */
    func SetInvincibilityStatus(player entity<Player>, invincible bool) {
        player<Player>.Invincible = invincible;
    }

    /* Set Movement Status for all players
    @param canMove The movement status to set
    */
    func SetMovementStatus(canMove bool) {
        SetAllPlayersMoveStatus(canMove);
    }

    // Add a M590 and a random rifle for each player
    func InitPlayerWeapons() {
        var rifleList = List<EResItem>{EResItem.AK47, EResItem.SCAR, EResItem.FAMAS, EResItem.XM8, EResItem.GROZAX, EResItem.AUG, EResItem.M4A1}
        var randomRifle = rifleList[RandomInt(0, List.Length(rifleList))]
        var m590 = EResItem.M590
        for index, player in GetAllPlayers(){
            // Add a list of items to player. Before add, delete all existing items
            player<PlayerController>.AddItemToPlayer(player, EResItem.VestLv3, 1)
            player<PlayerController>.AddItemToPlayer(player, EResItem.HelmetLv3, 1)
            if GetItemCount(player, EResItem.GlooWall as ItemIDType) != 0 && globalEntity<CombatRoundCounter>.GetCount() != 0 {
                DestroyItem(player, EResItem.GlooWall as ItemIDType, GetItemCount(player, EResItem.GlooWall as ItemIDType)) // Destroy the item when added
            }
            // player<PlayerController>.AddItemToPlayer(player, EResItem.GlooWall, 8)
            AddItem(player, EResItem.GlooWall as ItemIDType, 8, out var newGlooWall) // Add the item to the player
            if GetItemCount(player, EResItem.MedKit as ItemIDType) != 0 {
                DestroyItem(player, EResItem.MedKit as ItemIDType, GetItemCount(player, EResItem.MedKit as ItemIDType)) // Destroy the item when added
            }
            AddItem(player, EResItem.MedKit as ItemIDType, 4, out var newItem) // Add the item to the player
            if GetItemCount(player, EResItem.SuperMed as ItemIDType) != 0 {
                DestroyItem(player, EResItem.SuperMed as ItemIDType, GetItemCount(player, EResItem.SuperMed as ItemIDType)) // Destroy the item when added
            }
            AddItem(player, EResItem.SuperMed as ItemIDType, 1, out var newSuperMed) // Add the item to the player
            if GetItemCount(player, EResItem.Inhaler as ItemIDType) != 0 {
                DestroyItem(player, EResItem.Inhaler as ItemIDType, GetItemCount(player, EResItem.Inhaler as ItemIDType)) // Destroy the item when added
            }
            AddItem(player, EResItem.Inhaler as ItemIDType, 10, out var newInhaler) // Add the item to the player
            if GetItemCount(player, EResItem.Grenade as ItemIDType) != 0 {
                DestroyItem(player, EResItem.Grenade as ItemIDType, GetItemCount(player, EResItem.Grenade as ItemIDType)) // Destroy the item when added
            }
            AddItem(player, EResItem.Grenade as ItemIDType, 2, out var newGrenade) // Add the item to the player
            if GetItemCount(player, EResItem.FlashFreeze as ItemIDType) != 0 {
                DestroyItem(player, EResItem.FlashFreeze as ItemIDType, GetItemCount(player, EResItem.FlashFreeze as ItemIDType)) // Destroy the item when added
            }
            AddItem(player, EResItem.FlashFreeze as ItemIDType, 1, out var newFlashFreeze) // Add the item to the player
            if GetItemCount(player, EResItem.GlooMelter as ItemIDType) != 0 {
                DestroyItem(player, EResItem.GlooMelter as ItemIDType, GetItemCount(player, EResItem.GlooMelter as ItemIDType)) // Destroy the item when added
            }
            AddItem(player, EResItem.GlooMelter as ItemIDType, 2, out var newGlooMelter) // Add the item to the player
            if(globalEntity<CombatRoundCounter>.GetCount() == 1) {
                player<PlayerController>.AddItemToPlayer(player, m590, 1) // Add M590 to the player
                player<PlayerController>.AddItemToPlayer(player, randomRifle, 1) // Add random rifle to the player
                player<PlayerController>.AddItemToPlayer(player, EResItem.Muzzle, 1)
                player<PlayerController>.AddItemToPlayer(player, EResItem.Mag, 1)
                player<PlayerController>.AddItemToPlayer(player, EResItem.Foregrip, 1)
                player<PlayerController>.AddItemToPlayer(player, EResItem.Scope, 1)
                player<PlayerController>.AddItemToPlayer(player, EResItem.Stock, 1)
            }
        }
    }

    func ReaddAttachment(player entity<Player>) {
        AddItem(player, EResItem.Muzzle as ItemIDType, 2, out var newMuzzle)
        AddItem(player, EResItem.Mag as ItemIDType, 2, out var newMag)
        AddItem(player, EResItem.Foregrip as ItemIDType, 2, out var newForegrip)
        AddItem(player, EResItem.Scope as ItemIDType, 2, out var newScope)
        AddItem(player, EResItem.Stock as ItemIDType, 2, out var newStock)
        AddItem(player, EResItem.ShotgunStock as ItemIDType, 2, out var newShotgunStock)
    }
    /*
    As the RandomInt() random mechanism is kinda bad (high chance of getting the same value as the old value every call), keep it inside a loop so that we can ensure a different value is returned.
    However, to be safe, limit the random time to 20
    @param oldValue: the old stage index
    @return: the new stage index
    */
    func RandomStage(oldValue int) int{
        var attempts = 0
        while attempts < 20 {
            // Randomize the new stage index
            var newValue = RandomInt(0, globalEntity<GlobalGameManager>.availableStages)
            var diff bool = true
            for index, oldStage in oldStagesList {
                if newValue == oldStage {
                    diff = false // If the new value is the same as any of the old values, set diff to false
                    break // Break the loop as we found a match
                }
            }
            if diff {
                return newValue
            }
            // Debug only
            // var newValue = RandomInt(6, 7)
            // // Stop condition: When the new value is the same as the old value
            // return newValue // Return the new value immediately
            // Increase attempts if the new value is the same as the old value
            attempts++
        }
        return oldValue // After 20 attempts, return the old value if no new value is found
    }

    /*
    Reset skill of a player, by getting all the player's skills, then set it again.
    @param player: The player that needs to reset skills.

    NOTE: In 1.14.1, there is problem with the SetSkills function. In detail, the SetSkills() does not work with the List<SkillID>{} getting
    from GetSkills(). To fix this, the current solution is converting all of the skills to strings and then back to integers.
    */
    func ResetSkill(player entity<Player>) {
        var skills = GetSkills(player)
        var skillStringList = List<string>{}
        var updatedPlayerSkillList = List<SkillID>{}
        for index, skill in skills {
            Append(skillStringList, Convert.ToString(skill))
        }

        for index, skill in skillStringList{
            Convert.StringToInt(skill, out var result, out var isSuccess)
            if isSuccess {
                Append(updatedPlayerSkillList, result)
            } else {
                LogError("Error in getting skill for player " + player<Player>.NickName)
            }
        }
        SetSkills(player, updatedPlayerSkillList) // Set the skills for the player
    }
}